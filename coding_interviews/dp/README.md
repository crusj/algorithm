## 打家劫舍
街上有一排房屋，用一个包含非负整数的数组 nums 表示，每个元素 nums[i] 代表第 i 间房子中的现金数额。现在你是一名专业小偷，你希望尽可能多的盗窃这些房子中的现金，但是，相邻的房子不能被同时盗窃，否则会触发报警器。

> dp[n]的定义为打劫第前n家能够打劫到最大金额。

// base
dp[0] = 0
dp[1] = v[1]

// one
dp[n] = max(dp[n-1], dp[n-2] + v[n]) 

## 最短距离
设A 和B 是2 个字符串。要用最少的字符操作将字符串A 转换为字符串B。
这里所说的字符操作包括
(1)删除一个字符；
(2)插入一个字符；
(3)将一个字符改为另一个字符

> dp[i][j]的定义将长度为i的字符串转换为长度为j的字符串需要的最小操作数

// base
dp[i][j] = dp[0][j-1] + 1 // i == 0, j = 0..j // 增加i字符的次数
dp[i][j] = dp[i-1][0] + 1 // j == 0, i = 0..i // 删除i字符的次数

// one
dp[i][j] = dp[i-1][j-1]   // strI[i] == strJ[j]
// two
dp[i][j] = max(dp[i][j-1] + 1, dp[i-1][j-1] + 1, dp[i-1][j] +1) // strI[i] != strJ[j] // i插入一个字符、i改成对应j字符、删除一个字符

## 背包问题

### 01背包
一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

> dp[i][j]为将前i件物品放入承重为j的背包的最大价值

// base
dp[i][j] = 0 // i == 0 || j == 0

// one
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) // 不将第i件物品放入背包或将第i件物品放入背包 


### 完全背包
与01背包相同，条件每种物品有无限多个

> dp[i][j]为将前i件物品放入承重为j的背包的最大价值

// base
dp[i][j] = 0 // i == 0 || j == 0

// one
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]) // 不将第i件物品放入背包或将第i件物品放入背包(可以重复放) 

### 多重背包
一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

// base
>dp[i][j]为将前i件物品放入承重为j的背包的最大价值

// one
dp[i][j] = max(dp[i-1][j], max(
    dp[i][j- n[i] * w[i]] + n[i]*v[i] // n[i] in (0..n[i])
))

### 凑零钱问题
假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，需要用到尽量少的钞票。

> dp[n]代表凑出金额n需要用到的最少的钞票数量

// base
dp[0] = 0

// one
dp[n] = min(dp[n-1], dp[n-5], dp[n-10], dp[n-20], dp[n-50], dp[n-100]) +1

### 最短路径
问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。

> dp[t] = min(dp[r] + wR2T) r是所有到达t的点，wR2T是所有r点到t点的距离

### 最长上升子序列
最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。
e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。

> dp[n] = max(dp[m] + 1)  // for m < n  and arr[n] > arr[m]

### 扔鸡蛋

题目是这样：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 <= F <= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？


> dp[i][j] = min(dp[i-1][j-1], dp[n-i][j]) + 1  共i层楼k个鸡蛋，至少扔dp[i][j]此，在i层扔鸡蛋碎了，则往下层寻找，此时鸡蛋数减一，在i层扔鸡蛋没碎，则层数往上找，鸡蛋数不变

// base
dp[0][j] = 0  // 楼层为0零次
dp[i][1] = i  // 鸡蛋数为1则为线性查找需要对应楼层次

// one
dp[i][j] = min(dp[i-1][j-1] , dp[n-i][j]) + 1
